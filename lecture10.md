class: middle, center, title-slide

# Large-scale Distributed Systems

Lecture 10: Blockchain

???

- Insist on Nakamoto-consensus

---

# Today

.grid[
.col-3-4[
- *Blockchain*
- *Bitcoin*
- Further applications
]
.col-1-4[.center[![](figures/lec10/btc.png)]]
]


<br><br><br><br><br><br><br><br><hr>

Most of today's lecture slides are taken from Jonathan Jogenfors, "Cryptography Lecture 12: [Bitcoin and friends](https://www.icg.isy.liu.se/courses/tsit03/forelasningar/cryptolecture12.pdf)".

---

# Money vs the Internet

- Many everyday things have *moved* to the Internet.
- Communications, relations, entertainment, ... but **not money**.

<br>
.center.width-50[![](figures/lec10/euro.jpg)]
.caption[Why do we still need these?]

---

# What about credit cards?

- Credit cards are **inherently insecure**.
- Entire model is *backwards*:
    - Merchant takes the customer's CC number.
    - Merchant goes to the bank.
    - Merchant gives CC number to the customer's bank.
    - Bank gives money from the customer's account to the merchant.
- Something like this would be better:
    - Customer tells bank to give money to merchant.
    - That's it!

---

# Making money digital

- Why not create a **currency** based on *cryptography*?
- Our design goals should be a currency with the following properties:
    - Secure transfer in computer networks
    - Cannot be copied and reused
    - Anonymity
    - Offline transactions
    - Can be transferred to others
    - Can be subdivided

---

# The failure of electronic cash

- There have been several proposals for digital money.
- Until a few years ago, all had failed.
- No gain over existing systems:
    - Still need a central point of trust
    - Privacy: who monitors the system?
    - Can we entrust a bank with managing an entire currency?

---

# Bitcoin

.center.width-20[]

.grid[
.col-3-4[
- The bitcoin protocol was proposed in 2008.
- Takes care of:
    - Creation of new currency
    - Secure transactions
    - Protection against double-spending
    - Anybody can be a merchant or a customer
    - Pseudo-anonymity
]
.col-1-4[.center[![](figures/lec10/btc.png)]]
]

.center.width-70[![](figures/lec10/btc-paper.png)]

---

class: middle, center

# Bitcoin from scratch

Step by step, we will build a peer-to-peer currency, <br>
discussing strengths and weaknesses.

---

# v1: Public, signed transactions

.center.width-70[![](figures/lec10/transaction.png)]
.center["I, Alice, send one coin to Bob."]
<br>

- Alice publishes a **signed** message.
- Benefits:
    - Bob can *verify* the signature as being from Alice.
    - The transaction cannot be undone.
- Downsides:
    - No account balances.
    - Infinite number of coins. Very incomplete protocol.

---

# v2: Serial numbers

.center.width-70[![](figures/lec10/transaction.png)]
.center["I, Alice, send coin no. 856034 to Bob."]
<br>

- Duplicate transactions are easily spotted.
- How are the serial numbers created?
- Easy solution: Serial numbers are generated by a *trusted* source, like a bank.

---

# No middleman?

- A bank works, but can we remove the central point of trust?
- We want a decentralized, self-governing network.
- Instead, we establish a list of all transactions ever made.
- Computing an account balance is done by summing over all previous transactions for that account.
- This list is called the **blockchain** and is shared by all users.

---

# v3: The blockchain

.center.width-70[![](figures/lec10/transaction.png)]
.center["Bob checks his blockchain before accepting the transaction."]
<br>

- If he sees that the coin is owned by Alice, he accepts it.
- After the transaction is complete, Bob broadcasts his acceptance.
    - Bitcoin relies on a **gossiping** protocol for the broadcast.
- As soon as the other peers hear this broadcast, they will not allow *double-spending*.

---

# Double-spending

.center.width-70[![](figures/lec10/double-spending.png)]

- **Double-spending** is still possible.
- Alice can perform a double-spend before the acceptance broadcast is hear by enough peers.
- To solve this problem, we make Bob ask everybody else if a transaction is valid.
- Double-spending will be noticed before payment is accepted.

---

# Verifying transactions

- How many answers should Bob require? How can answers be trusted?
- A *majority vote* is **impossible**.
    - What if Alice controls other peers and spams Bob with false confirmations?
- There is no way to perform traditional authentication.
- But Bitcoin will not work if transactions cannot be reliably verified...

.center.width-60[![](figures/lec10/sybil.png)]
.caption[A sybil attack from Alice]

---

class: middle, center

We need *consensus*, in the presence of **malicious** peers!

---

# The Byzantine Generals Problem

---

# Impossibility result

---

# v4 (final): Proof of work

- To verify transactions, the Bitcoin protocol uses *Proof of Work* (PoW).
- Basic idea: We only trust solutions that are accompanied by a proof of someone having committed a large amount of resources to a problem.
- That is, we do not authenticate a *user*, but we authenticate the fact time/money/energy/etc has been spent.
- In order for Alice to make a double-spend, she **first has to spend energy** before Bob trusts here.
- Even better: we turn proof-of-work into a competition.

---

# The PoW challenge

- We want a problem that...
    - is difficult to solve
    - has solutions that are easy to verify
    - has scalable difficulty
- Finding (partial) hash collision  as proof-of-work:
    - A one-way hash function $h(x)$ has the following properties:
        - Easy to compute $h(x)$ from $x$.
        - Given $h(x)$, it is difficult to find $x'$ such that $h(x') = h(x)$.
    - Finding pre-images is the perfect proof-of-work!
    - Bitcoin uses $h(x)=\text{SHA256}(\text{SHA256}(x))$

---

# Mining

- Transactions are verified by special peers called **miners**.
- Assume that Alice's transaction message $m$ is broadcast:
    - "I, Alice, send coin no. 856034 to Bob."
- Mining algorithm:
    - A miner selects a random *nonce* $k$ and computes $h(m+k)$.
    - If $h(m+k)>T$, the miner chooses a new $k$ and tries again.
    - After a long time, a miner eventually finds $k$ such that $h(m+k)<T$ and broadcasts $k$.
    - Bob receives $k$ and checks that $h(m+k)<T$ to accept the transaction.

---

# Example

- Let the threshold $T$ be so that the hash value $h(m+k)$ needs five leading zeros and let $m$="AAA".

.center.width-50[![](figures/lec10/pow.png)]

- Note that in the normal case, $k$ is chosen randomly.
- There are several solutions $k$ to the problem $h(m+k)<T$.

---

# Mining is a competition (1)

.center.width-80[![](figures/lec10/mining1.png)]

---

# Mining is a competition (2)

.center.width-80[![](figures/lec10/mining2.png)]

---

# Mining is a competition (3)

.center.width-80[![](figures/lec10/mining3.png)]

---

# Mining is a competition (4)

.center.width-80[![](figures/lec10/mining4.png)]

---

# Mining is a competition (5)

.center.width-80[![](figures/lec10/mining5.png)]

---

# Mining is a competition (6)

.center.width-80[![](figures/lec10/mining6.png)]

---

# Blocks

---

# Transactions

---

# Each block gives security to the previous ones

---

# This is how Bitcoin works!

---

# Applications

---

# Summary

---

# References

- Nakamoto, Satoshi. "Bitcoin: A peer-to-peer electronic cash system." (2008): 28.
- Jonathan Jogenfors, "Cryptography Lecture 12: [Bitcoin and friends](https://www.icg.isy.liu.se/courses/tsit03/forelasningar/cryptolecture12.pdf)".
